---
title: gridcv_all_models_tecator.jl
weave_options:
  error: true
  wrap: true
  term: false
  #out_width: "50%"   # default
---

```julia
using JLD2, CairoMakie
using Jchemo, JchemoData
using Loess
```

#### Data importation

```julia
path_jdat = dirname(dirname(pathof(JchemoData)))
db = joinpath(path_jdat, "data/tecator.jld2") 
@load db dat
pnames(dat)
```

#### Data preparation and short description

```julia
X = dat.X
Y = dat.Y 
ntot, p = size(X)
```

```julia term = true
@head X 
@head Y
```

```julia
summ(Y)
```

```julia
namy = names(Y)[1:3]
```

```julia
typ = Y.typ
tab(typ)
```

```julia
wl = names(X)
wl_num = parse.(Float64, wl) 
```

```julia
plotsp(X, wl_num;
    xlabel = "Wavelength (nm)", ylabel = "Absorbance").f
```

#### Preprocessing

```julia
f = 15 ; pol = 3 ; d = 2 
Xp = savgol(snv(X); f = f, pol = pol, d = d) 
```

```julia
plotsp(Xp, wl_num;
    xlabel = "Wavelength (nm)", ylabel = "Absorbance").f
```

#### Split Tot ==> Train + Test

The model is tuned on **Train**, and the generalization error is estimated on **Test**.
Here the split of **Tot** is already provided inside the dataset (= variable `typ`), 
but **Tot** could also be split *a posteriori*, for instance by sampling (random, systematic 
or any other designs). 

```julia
s = typ .== "train"
Xtrain = Xp[s, :]
Ytrain = Y[s, namy]
Xtest = rmrow(Xp, s)
Ytest = rmrow(Y[:, namy], s)
ntrain = nro(Xtrain)
ntest = nro(Xtest)
ntot = ntrain + ntest
(ntot = ntot, ntrain, ntest)
```
Work on the second y-variable: 

```julia
j = 2  
nam = namy[j]    # y-variable
ytrain = Ytrain[:, nam]
ytest = Ytest[:, nam]
```

#### CV-Segments

```julia
segm = segmkf(ntrain, 4; rep = 20)
```

For slow models ==> only 3 replications:

```julia
segm_slow = segm[1:3] 
```

#### PLSR

```julia
nlv = 0:40
res = gridcvlv(Xtrain, ytrain; segm = segm, 
    score = rmsep, fun = plskern, nlv = nlv).res
```

```julia
plotgrid(res.nlv, res.y1;
    xlabel ="Nb. LVs", ylabel = "RMSEP").f
```

```julia
u = findall(res.y1 .== minimum(res.y1))[1]
res[u, :]
```

```julia
fm = plskern(Xtrain, ytrain; nlv = res.nlv[u]) ;
pred = Jchemo.predict(fm, Xtest).pred ;
rmsep(pred, ytest)
```

```julia
plotxy(pred, ytest; resolution = (500, 400),
    color = (:red, .5), bisect = true, 
    xlabel = "Prediction", ylabel = "Observed (Test)").f  
```

#### PLSR-AVG

```julia
nlv = ["0:10"; "0:20"; "0:30"; "0:50"]
typf = ["unif"]
#typf = ["unif"; "aic"; "stack"]
pars = mpar(nlv = nlv, typf = typf)
```

```julia
res = gridcv(Xtrain, ytrain; segm = segm,
    score = rmsep, fun = plsravg, pars = pars).res
```

```julia
u = findall(res.y1 .== minimum(res.y1))[1] 
res[u, :]
```

```julia
fm = plsravg(Xtrain, ytrain; nlv = res.nlv[u],
    typf = res.typf[u]) ;
pred = Jchemo.predict(fm, Xtest).pred 
rmsep(pred, ytest)
```

```julia
plotxy(pred, ytest; resolution = (500, 400),
    color = (:red, .5), bisect = true, 
    xlabel = "Prediction", ylabel = "Observed (Test)").f  
```

#### RR 

```julia
lb = 10.0.^(-15:.1:3) 
res = gridcvlb(Xtrain, ytrain; segm = segm,
    score = rmsep, fun = rr, lb = lb, verbose = false).res 
```

```julia
zres = res[res.y1 .< 3, :]
zlb = round.(log.(10, zres.lb), digits = 3)
plotgrid(zlb, zres.y1; step = .5,
    xlabel ="Lambda", ylabel = "RMSEP").f
```

```julia
u = findall(res.y1 .== minimum(res.y1))[1] 
res[u, :]
```

```julia
fm = rr(Xtrain, ytrain; lb = res.lb[u]) ;
pred = Jchemo.predict(fm, Xtest).pred
rmsep(pred, ytest)
```

```julia
plotxy(pred, ytest; resolution = (500, 400),
    color = (:red, .5), bisect = true, 
    xlabel = "Prediction", ylabel = "Observed (Test)").f  
```

#### COVSELR

```julia
nlv = [5; 10; 15; 20; 30]
pars = mpar(nlv = nlv)
```

```julia
res = gridcv(Xtrain, ytrain; segm = segm,
    score = rmsep, fun = covselr, pars = pars, 
    verbose = false).res
```

```julia
u = findall(res.y1 .== minimum(res.y1))[1] 
res[u, :]
```

```julia
fm = covselr(Xtrain, ytrain; nlv = res.nlv[u]) ;
pred = Jchemo.predict(fm, Xtest).pred 
rmsep(pred, ytest)
```

```julia
plotxy(pred, ytest; resolution = (500, 400),
    color = (:red, .5), bisect = true, 
    xlabel = "Prediction", ylabel = "Observed (Test)").f  
```

#### KRR 

```julia
lb = 10.0.^(-15:5) 
gamma = 10.0.^(-3:5) 
pars = mpar(gamma = gamma)
```

```julia
length(pars[1])
```

```julia
res = gridcvlb(Xtrain, ytrain; segm = segm,
    score = rmsep, fun = krr, lb = lb, pars = pars,
    verbose = false).res
```

```julia
u = findall(res.y1 .== minimum(res.y1))[1]
res[u, :]
```

```julia
fm = krr(Xtrain, ytrain; lb = res.lb[u], 
    gamma = res.gamma[u]) ;
pred = Jchemo.predict(fm, Xtest).pred
rmsep(pred, ytest)
```

```julia
plotxy(pred, ytest; resolution = (500, 400),
    color = (:red, .5), bisect = true, 
    xlabel = "Prediction", ylabel = "Observed (Test)").f  
```

#### KPLSR

```julia
nlv = 0:50
gamma = 10.0.^(-3:5) 
pars = mpar(gamma = gamma) 
```

```julia
length(pars[1])
```

```julia
res = gridcvlv(Xtrain, ytrain; segm = segm,
    score = rmsep, fun = kplsr, nlv = nlv, pars = pars,
    verbose = false).res
```

```julia
zres = res[res.y1 .< 20, :]
group = string.("gamma=", round.(log.(10, zres.gamma)))
plotgrid(zres.nlv, zres.y1, group;
    xlabel ="Nb. LVs", ylabel = "RMSEP").f
```

```julia
u = findall(res.y1 .== minimum(res.y1))[1] 
res[u, :]
```

```julia
fm = kplsr(Xtrain, ytrain; nlv = res.nlv[u], 
    gamma = res.gamma[u]) ;
```

```julia
pred = Jchemo.predict(fm, Xtest).pred 
rmsep(pred, ytest)
```

```julia
plotxy(pred, ytest; resolution = (500, 400),
    color = (:red, .5), bisect = true, 
    xlabel = "Prediction", ylabel = "Observed (Test)").f  
```

#### DKPLSR

```julia
nlv = 0:50
gamma = 10.0.^(-3:5) 
pars = mpar(gamma = gamma) 
```

```julia
length(pars[1])
```

```julia
res = gridcvlv(Xtrain, ytrain; segm = segm,
    score = rmsep, fun = dkplsr, nlv = nlv, pars = pars,
    verbose = false).res
```

```julia
zres = res[res.y1 .< 20, :]
group = string.("gamma=", round.(log.(10, zres.gamma)))
plotgrid(zres.nlv, zres.y1, group;
    xlabel ="Nb. LVs", ylabel = "RMSEP").f
```

```julia
u = findall(res.y1 .== minimum(res.y1))[1] 
res[u, :]
```

```julia
fm = dkplsr(Xtrain, ytrain; nlv = res.nlv[u], 
    gamma = res.gamma[u]) ;
pred = Jchemo.predict(fm, Xtest).pred 
rmsep(pred, ytest)
```

```julia
plotxy(pred, ytest; resolution = (500, 400),
    color = (:red, .5), bisect = true, 
    xlabel = "Prediction", ylabel = "Observed (Test)").f  
```

#### LWPLSR 

```julia
nlvdis = [10; 15] ; metric = ["mahal"] 
h = [1; 2; 5; Inf] ; k = [30; 50; 100]  
nlv = 0:15
pars = mpar(nlvdis = nlvdis, metric = metric, 
    h = h, k = k) 
```

```julia
length(pars[1])
```

```julia
res = gridcvlv(Xtrain, ytrain; segm = segm_slow,
    score = rmsep, fun = lwplsr, nlv = nlv, 
    pars = pars, verbose = false).res 
```

```julia
group = string.("nvldis=", res.nlvdis, ",h=", res.h, 
    ",k=", res.k)
plotgrid(res.nlv, res.y1, group; step = 2,
    xlabel ="Nb. LVs", ylabel = "RMSEP").f
```

```julia
u = findall(res.y1 .== minimum(res.y1))[1] 
res[u, :]
```

```julia
fm = lwplsr(Xtrain, ytrain; nlvdis = res.nlvdis[u],
    metric = res.metric[u], h = res.h[u], k = res.k[u], 
    nlv = res.nlv[u]) ;
pred = Jchemo.predict(fm, Xtest).pred 
rmsep(pred, ytest)
```

```julia
plotxy(pred, ytest; resolution = (500, 400),
    color = (:red, .5), bisect = true, 
    xlabel = "Prediction", ylabel = "Observed (Test)").f  
```

#### LWPLSR-AVG

```julia
nlvdis = [10; 15] ; metric = ["mahal"] 
h = [1; 2; 5; Inf] ; k = [30; 50; 100]  
nlv = ["1:5", "1:10"]
pars = mpar(nlvdis = nlvdis, metric = metric, 
    h = h, k = k, nlv = nlv) 
```

```julia
length(pars[1])
```

```julia
res = gridcv(Xtrain, ytrain; segm = segm_slow,
    score = rmsep, fun = lwplsravg, pars = pars, 
    verbose = false).res 
```

```julia
u = findall(res.y1 .== minimum(res.y1))[1] 
res[u, :]
```

```julia
fm = lwplsravg(Xtrain, ytrain; nlvdis = res.nlvdis[u],
    metric = res.metric[u], h = res.h[u], k = res.k[u], 
    nlv = res.nlv[u]) ;
pred = Jchemo.predict(fm, Xtest).pred 
rmsep(pred, ytest)
```

```julia
plotxy(pred, ytest; resolution = (500, 400),
    color = (:red, .5), bisect = true, 
    xlabel = "Prediction", ylabel = "Observed (Test)").f  
```

#### LWPLSR-S

```julia
nlv0 = [10; 15; 20]
metric = ["eucl"; "mahal"] 
h = [1; 2; 5] ; k = [30; 50; 100]  
nlv = 0:10
pars = mpar(nlv0 = nlv0, metric = metric, 
    h = h, k = k) 
```

```julia
length(pars[1])
```

```julia
res = gridcvlv(Xtrain, ytrain; segm = segm_slow,
    score = rmsep, fun = lwplsr_s, nlv = nlv, 
    pars = pars, verbose = false).res 
```

```julia
group = string.("nvl0=", res.nlv0, " metric =", res.metric, 
    " h=", res.h, " k=", res.k)
plotgrid(res.nlv, res.y1, group; step = 2,
    xlabel ="Nb. LVs", ylabel = "RMSEP").f
```

```julia
u = findall(res.y1 .== minimum(res.y1))[1] 
res[u, :]
```

```julia
fm = lwplsr_s(Xtrain, ytrain; nlv0 = res.nlv0[u], 
    metric = res.metric[u], h = res.h[u], 
    k = res.k[u], nlv = res.nlv[u]) ;
pred = Jchemo.predict(fm, Xtest).pred 
rmsep(pred, ytest)
```

```julia
plotxy(pred, ytest; resolution = (500, 400),
    color = (:red, .5), bisect = true, 
    xlabel = "Prediction", ylabel = "Observed (Test)").f   
```

**Working in a DKPLS score space:**

```julia
reduc = ["dkpls"]
nlv0 = [10; 15; 20; 30]
gamma = 10.0.^(-3:3) 
metric = ["mahal"] 
h = [1; 2; 5] ; k = [30; 50; 100]  
nlv = 0:10
pars = mpar(reduc = reduc, nlv0 = nlv0, gamma = gamma, 
    metric = metric, h = h, k = k) 
```

```julia
length(pars[1])
```

```julia
res = gridcvlv(Xtrain, ytrain; segm = segm_slow,
    score = rmsep, fun = lwplsr_s, nlv = nlv, 
    pars = pars, verbose = false).res 
```

```julia
group = string.("nvl0=", res.nlv0, ", gamma=", res.gamma,
    ", h=", res.h, " k=", res.k)
plotgrid(res.nlv, res.y1, group; step = 2, leg = false,
    xlabel ="Nb. LVs", ylabel = "RMSEP").f
```

```julia
u = findall(res.y1 .== minimum(res.y1))[1] 
res[u, :]
```

```julia
fm = lwplsr_s(Xtrain, ytrain; reduc = res.reduc[u], 
    nlv0 = res.nlv0[u], gamma = res.gamma[u], 
    metric = res.metric[u], h = res.h[u], 
    k = res.k[u], nlv = res.nlv[u]) ;
pred = Jchemo.predict(fm, Xtest).pred 
rmsep(pred, ytest)
```

```julia
plotxy(pred, ytest; resolution = (500, 400),
    color = (:red, .5), bisect = true, 
    xlabel = "Prediction", ylabel = "Observed (Test)").f  
```

#### CPLSR-AVG

```julia
ncla = 2:5 ; nlv_da = 1:5
nlv = ["0:10"; "0:15"; "0:20"; 
    "5:15"; "5:20"]
pars = mpar(ncla = ncla, nlv_da = nlv_da, 
    nlv = nlv)
```

```julia 
length(pars[1])
```

```julia
res = gridcv(Xtrain, ytrain; segm = segm,
    score = rmsep, fun = cplsravg, pars = pars, 
    verbose = false).res 
```

```julia
u = findall(res.y1 .== minimum(res.y1))[1] 
res[u, :]
```

```julia
fm = cplsravg(Xtrain, ytrain; ncla = res.ncla[u],
    nlv_da = res.nlv_da[u], nlv = res.nlv[u]) ;
pred = Jchemo.predict(fm, Xtest).pred 
rmsep(pred, ytest)
```

```julia
plotxy(pred, ytest; resolution = (500, 400),
    color = (:red, .5), bisect = true, 
    xlabel = "Prediction", ylabel = "Observed (Test)").f  
```

#### KNNR

```julia
nlvdis = [15; 20]  ; metric = ["eucl"; "mahal"] 
h = [1; 2; 4; Inf] ;
k = [1; collect(5:10:100)] 
pars = mpar(nlvdis = nlvdis, metric = metric, 
    h = h, k = k) 
```

```julia
length(pars[1])
```

```julia
res = gridcv(Xtrain, ytrain; segm = segm,
    score = rmsep, fun = knnr, pars = pars, 
    verbose = false).res ;
```

```julia
u = findall(res.y1 .== minimum(res.y1))[1]
res[u, :]
```

```julia
fm = knnr(Xtrain, ytrain; nlvdis = res.nlvdis[u], 
    metric = res.metric[u], h = res.h[u], k = res.k[u]) ;
pred = Jchemo.predict(fm, Xtest).pred ;
rmsep(pred, ytest)
```

```julia
plotxy(pred, ytest; resolution = (500, 400),
    color = (:red, .5), bisect = true, 
    xlabel = "Prediction", ylabel = "Observed (Test)").f  
```

#### RFR 

```julia
n_trees = [50]
n_subfeatures = LinRange(10, p, 5)
max_depth = [6; 10; 20; 2000]
pars = mpar(n_trees = n_trees, n_subfeatures = n_subfeatures, 
    max_depth = max_depth)
```

```julia
length(pars[1])
```

```julia
res = gridcv(Xtrain, ytrain; segm = segm,
    score = rmsep, fun = rfr_dt, pars = pars, 
    verbose = false).res ;
```

```julia
u = findall(res.y1 .== minimum(res.y1))[1]
res[u, :]
```

```julia
fm = rfr_dt(Xtrain, ytrain; n_trees = res.n_trees[u], 
    n_subfeatures = res.n_subfeatures[u], 
    max_depth = res.max_depth[u]) ;
pred = Jchemo.predict(fm, Xtest).pred
rmsep(pred, ytest)
```

```julia
plotxy(pred, ytest; resolution = (500, 400),
    color = (:red, .5), bisect = true, 
    xlabel = "Prediction", ylabel = "Observed (Test)").f  
```

